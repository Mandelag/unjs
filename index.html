<!--
//Author : Hussein Nasser
//Date   : Jan-23-2018
//Email  : hnasser@esri.com
//Twitter: @hnasr
-->

<html>
<head>
<title>Utility Network - Javascript</title>

<script>
  var dojoConfig = {
    has: {
      "esri-featurelayer-webgl": 1
    }
  };
</script>

    <script src = 'https://js.arcgis.com/4.6'></script>
    <script src = 'utilitynetwork.js'></script>
    <script src = 'portal.js'></script>
	<link rel = "stylesheet" href = "https://js.arcgis.com/4.6/esri/css/main.css">
</head>
<body>
     <h4>Utility Network - Web Trace Sample</h4>
    <table>
        <tr>
            <td valign = top>
                    <table id = 'tblMain'>
                            <tr>
                                <td><label>Enterprise Url: </label></td><td><input type="text" id = "portalUrl" value = "https://enterpriseurl/portal" style = 'width:300px'></td>
                            </tr>
                            <tr>
                                <td><label>Username: </label></td><td> <input type="text" id = "username" value = "user" style = 'width:150px'></td>
                            </tr>
                           <tr>
                                <td><label>Password: </label></td><td><input type="password" id = "password" value = "pass" style = 'width:150px'></td>
                           </tr>
                           <tr>
                                <td colspan =2 align =right><button id = 'btnConnect'>Connect</button></td>
                           </tr>

                            <tr>
                                <td><label>Items</label></td><td><select id = 'cmbItems'></select></td>
                            </tr>
                            <tr>
                                 <td><label>Domain Networks</label></td><td><select id = 'cmbDomainNetworks'></select></td>
                            </tr>  
                            <tr>
                                 <td><label>Tiers</label></td><td><select id = 'cmbTiers'></select></td>
                            </tr>
                            <tr>
                                 <td><label>Subnetworks</label></td><td><select id = 'cmbSubnetworks'></select></td>
                            </tr> 
                         
                            <tr>
                                <td colspan = 2  align = right><button id = 'btnClearTraceLocations'>Clear</button> <button id = 'btnStartingPoint'>Set Starting Points</button><button id = 'btnBarriers'>Set Barriers</button> </td>
                                
                            </tr>
                            <tr>
                                <td colspan = 2 align = right><button id = 'btnTraceConnected'>Connected Trace</button> <button id = 'btnTrace'>Subnetwork Trace</button> <button id = 'btnTraceIsolation'>Isolation Trace (Water only)</button>  </td> 
                            </tr>
                            <tr>
                                <td colspan = 2 align = left><table id ='traceLocations'></table></td>                                
                            </tr>
                            <tr>
                                <td colspan = 2><label id = 'lblStatus'></label></td>
                           </tr>
                        </table>
            </td>
            <td>
                       <table>
                            <tr>
                                <td><div id = 'mapview' style='width:900px;height:700px'></div></td>
                            </tr>
                        </table>
            </td>
            
        </tr>
    </table>
   

  

<script>
    let highlight = null;
    let portal;
    let mapView;
    let GraphicClass;
    let handles = [];
    let un;
    let gl;
    let locationId = 0;
    const SELECTION_COLOR = [136, 220, 232, 0.7];
    const SELECTION_SIZE = 4;
    const TRACING_STARTLOCATION_BUFFER = 3;
    const TRACING_STARTPOINT_COLOR = [20, 158, 29, 0.7];
    const TRACING_BARRIER_COLOR = [211, 23, 51, 0.7];
    const TRACELOCATION_START = "startingPoint";
    const TRACELOCATION_BARRIER = "barrier";

    const DEFAULT_SPATIAL_REFERENCE =   {
                "wkid": 102100,
                "latestWkid": 3857
                }

 

    let updateStatus = text => document.getElementById("lblStatus").textContent = text;
    let activeTraceLocation;

    let mapClick = event => {
         event.stopPropagation();
         
         let color = activeTraceLocation === TRACELOCATION_START ? TRACING_STARTPOINT_COLOR : TRACING_BARRIER_COLOR;

         mapView.hitTest({x: event.x, y: event.y}).then(hitResults=>{
            
            let supportedClasses = ["esriUNFCUTDevice", "esriUNFCUTJunction", "esriUNFCUTLine"] //, "esriUNFCUTLine" ]
            if (hitResults.results.length)
            {               


                hitResults.results.forEach(g=>{
                    
                    let img = document.createElement("img");
                    
                    if (activeTraceLocation === TRACELOCATION_START)
                        img.src = "images/startPoint.png"
                    else
                        img.src = "images/barrier.png";
                    
                    let rowTraceLocation = document.createElement("tr");
                    let columnElement = document.createElement("td");
                   // let columntraceLocationType = document.createElement("td");
                    let columnTerminal = document.createElement("td");
                    rowTraceLocation.appendChild(img)
                    rowTraceLocation.appendChild(columnElement);
                 //   rowTraceLocation.appendChild(columntraceLocationType);
                    rowTraceLocation.appendChild(columnTerminal);
                    let deleteTraceLocation = document.createElement("button");
                    deleteTraceLocation.textContent = "X"
                    deleteTraceLocation.addEventListener("click", e => {
                        traceLocations.removeChild(rowTraceLocation);
                        //try to remove the graphic
                        
                        for (let i = 0; i < gl.graphics.items.length ; i++ )
                        {
                            let g = gl.graphics.items[i];
                            if (g.name === rowTraceLocation.globalId)   
                            {                      
                                gl.remove(g);
                                break;
                            }
                          
                        } 
                           
 
                    });
                    rowTraceLocation.appendChild(deleteTraceLocation);
                    
                    let at = un.getAssetType(g.graphic.layer.layerId,  getVal(g.graphic.attributes, "assetgroup"), getVal(g.graphic.attributes, "assettype"));
                    //if it is not a device or a junction or a line exit..
                    if (!supportedClasses.find( c => c == at.utilityNetworkFeatureClassUsageType  )) return;
                    locationId++;
                    rowTraceLocation.globalId = getVal(g.graphic.attributes,"globalid");
                    rowTraceLocation.locationId = locationId;
                    rowTraceLocation.isTerminalConfigurationSupported = at.isTerminalConfigurationSupported;
                    rowTraceLocation.layerId = g.graphic.layer.layerId;
                    rowTraceLocation.assetGroupCode = getVal(g.graphic.attributes, "assetgroup");
                    rowTraceLocation.assetTypeCode = getVal(g.graphic.attributes, "assettype");

                    columnElement.textContent =  " ("  + at.assetGroupName + "/" + at.assetTypeName + ") "
                   // columntraceLocationType.textContent = activeTraceLocation;
                    //if termianls supported show it 
                    if (at.isTerminalConfigurationSupported == true)
                    {
                        let terminalList = document.createElement("select");
                        terminalList.id = "cmbTerminalConfig" + locationId;
                        let terminalConfiguration = un.getTerminalConfiguration(at.terminalConfigurationId);
                        terminalConfiguration.terminals.forEach(t => {
                            let terminalItem = document.createElement("option");
                            terminalItem.textContent = t.terminalName;
                            terminalItem.value = t.terminalId;
                            terminalList.appendChild(terminalItem);
                        }) 
                        columnTerminal.appendChild(terminalList);
                    }
                    
                   
                    rowTraceLocation.traceLocationType = activeTraceLocation;
                    traceLocations.appendChild(rowTraceLocation);

                    //create graphic on the map
                    require(["esri/geometry/geometryEngineAsync"],  function(geometryEngineAsync) 
                    {      
                        (async function (){
                        let bufferedGeo =  await geometryEngineAsync.buffer(g.graphic.geometry, TRACING_STARTLOCATION_BUFFER);
                        gl.graphics.add(getGraphic("polygon", bufferedGeo, color, rowTraceLocation.globalId));
                        })();
                    });
                })

               

            }

         });


        
     } ;

   //Start Execution//
    let cmbItems = document.getElementById("cmbItems");
    let cmbDomainNetworks = document.getElementById("cmbDomainNetworks");
    let cmbTiers = document.getElementById("cmbTiers");
    let cmbSubnetworks = document.getElementById("cmbSubnetworks");
    let btnTrace = document.getElementById("btnTrace");
    let btnStartingPoint = document.getElementById("btnStartingPoint");
    let btnBarriers = document.getElementById("btnBarriers");
    let btnClearTraceLocations = document.getElementById("btnClearTraceLocations");
    let btnTraceConnected = document.getElementById("btnTraceConnected"); 
    let traceLocations = document.getElementById("traceLocations");

    let handleStartPoints; 
    let handleBarriers;


    btnClearTraceLocations.addEventListener("click",  e => {
        while(traceLocations.firstChild) traceLocations.removeChild(traceLocations.firstChild);
        mapView.graphics = [];
        gl.graphics = [];
    })



    
 //only for water
 function IsolationTrace() {

//run upstream trace, stop when you find protective device valves
//trace configuration for barrier protective {"includeContainers":true,"includeContent":false,"includeStructures":true,"includeBarriers":true,"validateConsistency":true,"domainNetworkName":"Water","tierName":"Distribution System","targetTierName":"","subnetworkName":"","diagramTemplateName":"","shortestPathNetworkAttributeName":"","filterBitsetNetworkAttributeName":"","traversabilityScope":"junctionsAndEdges","conditionBarriers":[{"name":"Device Status","type":"networkAttribute","operator":"equal","value":0,"combineUsingOr":false,"isSpecificValue":true}],"functionBarriers":[],"arcadeExpressionBarrier":"","filterBarriers":[{"name":"Category","type":"category","operator":"equal","value":"Disconnecting","combineUsingOr":true,"isSpecificValue":true},{"name":"Category","type":"category","operator":"equal","value":"Protective","combineUsingOr":false,"isSpecificValue":true}],"filterFunctionBarriers":[],"filterScope":"junctionsAndEdges","functions":[],"nearestNeighbor":{"count":-1,"costNetworkAttributeName":"","nearestCategories":[],"nearestAssets":[]},"outputFilters":[],"outputConditions":[{"name":"Category","type":"category","operator":"equal","value":"Disconnecting","combineUsingOr":true,"isSpecificValue":true},{"name":"Category","type":"category","operator":"equal","value":"Protective","combineUsingOr":false,"isSpecificValue":true}],"propagators":[]}
let traceConfiguration = {"includeContainers":true,"includeContent":false,"includeStructures":true,"includeBarriers":true,"validateConsistency":false,"domainNetworkName":"Water","tierName":"Distribution System","targetTierName":"","subnetworkName":"","diagramTemplateName":"","shortestPathNetworkAttributeName":"","filterBitsetNetworkAttributeName":"","traversabilityScope":"junctionsAndEdges","conditionBarriers":[{"name":"Device Status","type":"networkAttribute","operator":"equal","value":0,"combineUsingOr":false,"isSpecificValue":true}],"functionBarriers":[],"arcadeExpressionBarrier":"","filterBarriers":[{"name":"Category","type":"category","operator":"equal","value":"Disconnecting","combineUsingOr":true,"isSpecificValue":true},{"name":"Category","type":"category","operator":"equal","value":"Protective","combineUsingOr":false,"isSpecificValue":true}],"filterFunctionBarriers":[],"filterScope":"junctionsAndEdges","functions":[],"nearestNeighbor":{"count":-1,"costNetworkAttributeName":"","nearestCategories":[],"nearestAssets":[]},"outputFilters":[],"outputConditions":[{"name":"Category","type":"category","operator":"equal","value":"Disconnecting","combineUsingOr":true,"isSpecificValue":true},{"name":"Category","type":"category","operator":"equal","value":"Protective","combineUsingOr":false,"isSpecificValue":true}],"propagators":[]}
let traceLocationsParam = getTraceLocationsParam();
un.upstreamTrace(traceLocationsParam, null, null , null, traceConfiguration)
.then(traceResults =>  drawTraceResults(un, traceResults, TRACING_BARRIER_COLOR))
.catch(err=> updateStatus(err));

//drawTraceResults
}



    //read the form and build the trace locations 
    function getTraceLocationsParam () {
        
        let traceLocationsParam = [];
        traceLocations.childNodes.forEach(li =>
        {    
         let startLocation = {};
         startLocation.globalId = li.globalId;
         startLocation.layerId = li.layerId;
         startLocation.assetGroupCode = li.assetGroupCode;
         startLocation.assetTypeCode = li.assetTypeCode;
        if (li.isTerminalConfigurationSupported == true)
        {   
            let cmbTerminalConfig = document.getElementById("cmbTerminalConfig" + li.locationId);
            startLocation.terminalId = cmbTerminalConfig.options[cmbTerminalConfig.selectedIndex].value;
        }
        startLocation.traceLocationType = li.traceLocationType;
        traceLocationsParam.push(startLocation)
        });

      return traceLocationsParam;
 
  }

    btnTraceConnected.addEventListener("click", e => {
        updateStatus("Tracing...");
        let traceLocationsParam = getTraceLocationsParam();
    //only attempt to trace when there is at leats one starting point
     if (!traceLocationsParam.length)
       {
           updateStatus("No starting points were found.");
           return;
       }

       un.connectedTrace(traceLocationsParam).then (traceResults =>  drawTraceResults(un, traceResults)).catch(er=>updateStatus(er))


    });


    
    btnTraceIsolation.addEventListener("click", e => {
        updateStatus("Running Isolation Tracing...");
        IsolationTrace();
           });

          

   
    btnBarriers.addEventListener("click" , e => {
            
        if (activeTraceLocation == undefined)  mapView.on("click", mapClick);
 
        activeTraceLocation = TRACELOCATION_BARRIER;
 
      
    })

    btnStartingPoint.addEventListener("click", e => {
  
        if (activeTraceLocation == undefined)  mapView.on("click", mapClick);
       activeTraceLocation = TRACELOCATION_START;
       
       
    })
  
    cmbItems.addEventListener("change", async function (e) {
        

        let itemId = e.target.options[e.target.selectedIndex].id;
        updateStatus("Loading item...");
        let itemData = await portal.loadItem(itemId);
        updateStatus("Item Loaded");
        // get the first operational layer so we know the feature service
        let serviceUrl = itemData.operationalLayers[0].url;
        let arrayService = serviceUrl.split("/")
        arrayService.length--;       
        serviceUrl = arrayService.join("/");
        un = new UtilityNetwork(portal.token, serviceUrl );
        let serviceJson = un.featureServiceJson;
        //query utility network data element
        //alert(JSON.parse(response).controllerDatasetLayers.utilityNetworkLayerId)
        //load service, map and UN in memory
        await un.load();
        loadUtilityNetwork(un, itemId, "mapview");

        //started populating domain networks

        //when someone changes the domain network list all tiers

        btnTrace.onclick = function(){
        let domainNetworkName = cmbDomainNetworks.options[cmbDomainNetworks.selectedIndex].textContent;
        let tierName = cmbTiers.options[cmbTiers.selectedIndex].textContent;
        let subnetworkName = "";
        //if subnetwork is not selected
        if (cmbSubnetworks.options[cmbSubnetworks.selectedIndex] != undefined)
            subnetworkName  = cmbSubnetworks.options[cmbSubnetworks.selectedIndex].textContent;

        let traceStart = new Date().getTime();
        updateStatus("Tracing...");
        let traceLocationsParam = getTraceLocationsParam();
        un.subnetworkTrace(traceLocationsParam, domainNetworkName, tierName , subnetworkName)
        .then(traceResults =>  drawTraceResults(un, traceResults))
        .catch(err=> updateStatus(err));
        }


        cmbDomainNetworks.onchange = function(e) {
        // e.target.selectedIndex
        //clear tiers, subnetworks
        while(cmbTiers.firstChild)cmbTiers.removeChild(cmbTiers.firstChild);
        while(cmbSubnetworks.firstChild)cmbSubnetworks.removeChild(cmbSubnetworks.firstChild); 
        let selectedDomainNetwork = e.target.options[e.target.selectedIndex].textContent;

        let domainNetwork = un.getDomainNetwork(selectedDomainNetwork);

        domainNetwork.tiers.forEach(tier => { 
        let tn = document.createElement("option");
        tn.textContent  = tier.name;
        cmbTiers.appendChild(tn);
        })
        cmbTiers.selectedIndex=-1; 

        }


        cmbTiers.onchange= function (e){

        while(cmbSubnetworks.firstChild)cmbSubnetworks.removeChild(cmbSubnetworks.firstChild);
        let selectedDomainNetwork = cmbDomainNetworks.options[cmbDomainNetworks.selectedIndex].textContent;
        let selectedTier = cmbTiers.options[cmbTiers.selectedIndex].textContent;

        un.getSubnetworks(selectedDomainNetwork,selectedTier).then(results=>{

    
        results.features.forEach(feature=> {
            let sn = document.createElement("option");
            for (let propt in feature.attributes)
                if (propt.toUpperCase() === "SUBNETWORKNAME")
                sn.textContent  = feature.attributes[propt];
            
            cmbSubnetworks.appendChild(sn);
        })
        cmbSubnetworks.selectedIndex=-1;
        })
        }
        


        cmbSubnetworks.onchange = function (){

        mapView.graphics = []
        let subnetworkName = cmbSubnetworks.options[cmbSubnetworks.selectedIndex].textContent;
        un.query(un.subnetLineLayerId, "SUBNETWORKNAME = '" + subnetworkName + "'").then (rowsJson => {
        let featureLayer = mapView.byId(un.subnetLineLayerId);
       
        /* Highlight bug doesn't work with feature service
        mapView.whenLayerView(featureLayer).then(lyrView => {
           if (highlight) {
                highlight.remove();
                highlight = null;
            }
            highlight = lyrView.highlight([rowsJson.features[0].attributes["OBJECTID"]])

        })
        */

         let polylineGraphic =  getGraphic("line", rowsJson.features[0].geometry);
        
         mapView.graphics.add(polylineGraphic);
         mapView.then(e=>mapView.goTo(polylineGraphic.geometry));
        });
        }

//populate domain networks, clear list first
while(cmbDomainNetworks.firstChild)cmbDomainNetworks.removeChild(cmbDomainNetworks.firstChild);
while(cmbTiers.firstChild)cmbTiers.removeChild(cmbTiers.firstChild);
while(cmbSubnetworks.firstChild)cmbSubnetworks.removeChild(cmbSubnetworks.firstChild); 
un.dataElement.domainNetworks.forEach(domainNetwork => { 
let dn = document.createElement("option");
dn.textContent  = domainNetwork.domainNetworkName;
cmbDomainNetworks.appendChild(dn);
})
cmbDomainNetworks.selectedIndex= -1;

 

    });

    

    
    document.getElementById("btnConnect").addEventListener("click", function() {     
        let portalUrl = document.getElementById("portalUrl").value;
        let username = document.getElementById("username").value;
        let password = document.getElementById("password").value;
        //clear the list of services.
        while (cmbItems.firstChild) cmbItems.removeChild(cmbItems.firstChild);
        portal = new Portal(portalUrl,username, password);    
        portal.connect().then(token=> {
                        //populate domain networks, clear list first
            while(cmbDomainNetworks.firstChild)cmbDomainNetworks.removeChild(cmbDomainNetworks.firstChild);
            while(cmbTiers.firstChild)cmbTiers.removeChild(cmbTiers.firstChild);
            while(cmbSubnetworks.firstChild)cmbSubnetworks.removeChild(cmbSubnetworks.firstChild); 
            portal.items().then(myItems=>  {   
                    myItems.forEach( a => {
                        if (a.type === "Web Map")
                        {
                        let listItem = document.createElement("option");
                        listItem.textContent = a.title;
                        listItem.url = a.url;
                        listItem.id = a.id;
                        cmbItems.appendChild(listItem);
                        }           
                }
           
                                )
        if (cmbItems.options.length === 0) updateStatus("No web maps found for user  " + username);
                    cmbItems.selectedIndex = -1;
    
    } )
        
        
        }
        ).catch(rejected=>updateStatus ("Unable to connect to portal. " + rejected));
    })

 





    var createGroupedArray = function(arr, chunkSize) {
        var groups = [], i;
        for (i = 0; i < arr.length; i += chunkSize) {
            groups.push(arr.slice(i, i + chunkSize));
        }
        return groups;
    }



    

    function getGraphic(type, geometry, color=SELECTION_COLOR, name)
    {   


        let symbol;
        let geometryObject;

        switch (type)
        {
        case "point" :
              
            symbol = {
            type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
            color: color,
            size:SELECTION_SIZE,
            outline: { // autocasts as new SimpleLineSymbol()
            color: color,
            width: SELECTION_SIZE
            }
          }

            geometryObject = {
            type: "point",
            x: geometry.x,
            y: geometry.y,
            spatialReference :  DEFAULT_SPATIAL_REFERENCE
                }

                break;
        case "line":
      
            symbol= {
                        type: "simple-line", // autocasts as SimpleLineSymbol()
                        color: color,
                        width: SELECTION_SIZE
                    };
              
            geometryObject = {
            type: "polyline",
            paths: geometry.paths,
            spatialReference:  DEFAULT_SPATIAL_REFERENCE
                }
        break;
        case "polygon":

      symbol = {
        type: "simple-fill", // autocasts as new SimpleFillSymbol()
        color: color,
        outline: { // autocasts as new SimpleLineSymbol()
          color: [255, 255, 255],
          width: SELECTION_SIZE
        }
      };
              

        geometryObject = {
            type: "polygon",
            rings: geometry.rings,
            spatialReference:  DEFAULT_SPATIAL_REFERENCE
        }

    }

        return   new GraphicClass({
            geometry: geometryObject,
            symbol: symbol,
            name: name
            });
  
    }


    function loadUtilityNetwork(utilityNetwork, itemId, mapViewDiv)
        {
            let token = portal.token;
            let serviceJson  = utilityNetwork.featureServiceJson;
            let serviceUrl = utilityNetwork.featureServiceUrl;
            
            require(["esri/Map", "esri/views/MapView", "esri/layers/FeatureLayer", "esri/layers/MapImageLayer","esri/WebMap", "esri/identity/IdentityManager", "esri/widgets/LayerList", "esri/layers/GraphicsLayer", "esri/Graphic"],
             function (Map, MapView, FeatureLayer, MapLayer, WebMap,  IdentityManager, Toc, GraphicsLayer, Graphic){
                 
                GraphicClass = Graphic;
                IdentityManager.registerToken({server: serviceUrl, token: token});
                IdentityManager.registerToken({server: portal.url, token: token});
                let mapviewDiv = document.getElementById(mapViewDiv);

                while (mapviewDiv.firstChild) mapviewDiv.removeChild(mapviewDiv.firstChild);
                //let map = new Map ({basemap:"streets-night-vector"}); //streets-night-vector
                let webmap = new WebMap({portalItem : {id : itemId, 
                portal : { 
                    url: portal.url
                }
                }});
 
                mapView = new MapView({container: mapViewDiv, map : webmap})
                mapView.byId = layerId => mapView.map.layers.find(l => l.layerId == layerId);
               
                gl = new GraphicsLayer();
                gl.screenSizePerspectiveEnabled = true
                mapView.map.add(gl);
                //let toc = new Toc({view: mapView, position: "bottom-left"});
                //mapView.ui.add(toc);
                  
            })  
        
        }

     

        function drawTraceResults(un, traceResults, color = SELECTION_COLOR)
        {  
 
        let promises = [];
        for (let layerId in traceResults.layers)
        {
            let layerObj = traceResults.layers[layerId];
            let subOids = createGroupedArray(layerObj.objectIds, 50);
            subOids.forEach(oidGroup =>  promises.push(un.query(layerId, "1=1", layerObj, oidGroup.join(","))));            
        }

        Promise.all(promises).then(rows => 
            {   
                mapView.graphics = [];
                let graphics = [];
                let geometries = [];
                let featureLayer = mapView.byId(rows.layerId);
                for (let featureSet of rows)
                {
                    let layerObj = featureSet.obj;
                    if (featureSet.features != undefined)
                    /*highlight bug not ready yet... 10.6.1 
                    mapView.whenLayerView(featureLayer).then(layerView => 
                    
                    featureSet.features.forEach(f => layerView.highlight(f.attributes["OBJECTID"]))

                );*/

                     for (let g of featureSet.features)
                     {  
                       
                       let graphic = getGraphic(layerObj.type, g.geometry, color);
                       graphics.push(graphic);                        
                    } 
                                            
                    
                 }

               //  let selectionDurationms = new Date().getTime() - selectionStart;
                // let drawingStartTime = new Date().getTime();
                 mapView.graphics.addMany(graphics);
                 updateStatus("Done");
                 //mapview takes time to render.. 
                // let drawingDurationms = new Date().getTime() - drawingStartTime;
                 //updateStatus(graphics.length + " features returned from the trace. Elapsed trace time : " + traceDurationms/1000 + " seconds. Elapsed selection time: " + selectionDurationms / 1000 + " seconds. Drawing duration time: " + drawingDurationms/ 1000 + " Total time: " + (traceDurationms + selectionDurationms + drawingDurationms)/ 1000 + " seconds" );
                
           
                // mapView.goTo(graphics);
                 /*
                 require(["esri/geometry/geometryEngineAsync"],  function(geometryEngine)
                 {
                    geometryEngine.union(geometries["point"]).then (unionLine=>  
                    {
                     let graphic = getGraphic("point",unionLine);
                     graphics.push(graphic);        
               
                    mapView.graphics.addMany(graphics);
                }
                 ).catch(err=> alert("failed to union" + err));
                 });*/
            
                
            })

        }




let getVal = function(obj, prop){
  prop = (prop + "").toLowerCase();
  for(var p in obj){
     if(obj.hasOwnProperty(p) && prop == (p + "").toLowerCase()){
           return obj[p];
           break;
      }
   }
 return undefined;
}

</script>

</body>
</html>